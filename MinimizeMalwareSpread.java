import java.util.Arrays;

public class MinimizeMalwareSpread {
    /**
     * https://leetcode.com/problems/minimize-malware-spread/description/
     Time complexity - o(n2) - going through entire  grid
     Space complexity - o(n) - colors o(n) + groups o(n) + infected +o(n) + recursive stack
     4n 4 is constant so we ignore and o(n)


     Approach - Have to figure distinct groups. Then perform dfs on them
     create colors array. Nodes = indices of an array.
     For each node in the same group assign same color.

     Create groups array. indices = Colors
     in groups for each indices which indicates a color iterate through colors array
     and add number of nodes belongign to that group.

     create infected array - indices = colors. elements to number of i
     nfected nodes belonging to that color
     from initial array find infected  nodes belongign to each group.
     Answer will lie in initial array.
     create answer variable and assign to -1;
     start iterating through initial array.
     Iterate through initial array,
     if the group that node belongs to have more than one infected nodes, discard it and proceed.
     if group that node belongs to have 1 infected node assign it to the answer.
     Proceed and if we find only one infected to next elements group,
     check by eleminating which server we will save more uninfected server,
     change the answer to that.
     if both answers has same number of servers saved,
     check the lowe index in the initial array(as per problem statement).
     if answer is still -1 at the end, find the min value from initial and return.






     */
    int[] colors;
    int color;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        if(graph==null || graph.length==0){
            return 0;
        }
        int n = graph.length;
        colors = new int[n];
        Arrays.fill(colors, -1);
        for (int i=0; i<n; i++){
            if(colors[i] == -1){
                dfs(graph, i);
                color++;
            }
        }
        int[] groups = new int[color];
        //iterate over colors array
        //for each index(Node) get the color code and keep adding to groups array at that index.
        for(int i=0; i<n;i++){
            int index = colors[i];
            groups[index]++;
        }
        // Create infected array for length number of groups which is given by color.
        int [] infected = new int[color];
        //iterate through initial and assign number of infected to each group.
        for(int i=0; i<initial.length;i++){
            int node = initial[i];
            int currentColor = colors[node];
            infected[currentColor]++;
        }
        //iterate through ing=fected and find the answer
        int answer = -1;
        for(int i=0;i< initial.length; i++){
            int node = initial[i];
            int currentColor = colors[node];
            if(infected[currentColor] == 1){
                if(answer == -1){
                    answer = initial[i];
                }else if(groups[currentColor] >groups[colors[answer]]){
                    answer = initial[i];
                }else if(groups[currentColor] == groups[colors[answer]] && answer > initial[i]){
                    answer = initial[i];
                }
            }
        }
        if(answer ==-1){
            int min = Integer.MAX_VALUE;
            for(int i=0; i<initial.length; i++){
                min = Math.min(min, initial[i]);
            }
            return min;
        }
        return answer;
    }

    private void dfs(int[][] graph, int v) {
        if (colors[v] != -1) {
            return;
        }
        colors[v] = color;
        for (int i = 0; i < graph.length; i++) {
            if (graph[v][i] == 1) {
                dfs(graph, i);
            }
        }
    }
}
